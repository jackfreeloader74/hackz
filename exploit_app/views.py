from django.shortcuts import render, redirect
from django.http import HttpResponse, JsonResponse
from django.core import serializers

from exploit_app.models import Program, Command, Tag, Stage, Category

from django.shortcuts import render, get_object_or_404
from django.core.paginator import Paginator
from exploit_app import exploit_lib

from django.db.models import Q

from exploit_app.exploit_lib import Filter
from dal import autocomplete

# Create your views here.
def index(request):

    stages = Stage.objects.all()
    print("Stages ", stages)
    context = {
                'stages' : stages
              }

    return render(request, 'exploit_app/search.html', context)


def command_view(request, command_id):

    command = get_object_or_404(Command, pk=command_id)
    program = command.program

    stage_list  = exploit_lib.prettyify_list(command.program.stages.all())
    tag_list = exploit_lib.prettyify_list(command.tags.all())
    references = command.references.all()

    ## Commands
    context = {
                'command' : command,
                'stage_list' : stage_list,
                'tag_list' : tag_list,
                'references' : references,
                'program' : program
              }

    return render(request, 'exploit_app/command.html', context)


# View to display all details about a single program
def program_view(request, program_id):
    paginate_by = 2
    program = get_object_or_404(Program, pk=program_id)

    ## Commands (paginated)
    command_list = program.command_set.all()
    paginator = Paginator(command_list, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    references = program.references.all()

    # Stages
    stage_list = program.stages.all()
    stage_list = [str(element) for element in stage_list]
    presentable_stage_list  = ", ".join(stage_list)

    context = {
                'program': program,
                'command_list' : command_list,
                'page_obj' : page_obj,
                'presentable_stage_list' : presentable_stage_list,
                'references' : references,
                'category' : program.category
              }

    return render(request, 'exploit_app/program.html', context)




# View to create a new program
def create_program_view(request):

    context = {

              }

    return render(request, 'exploit_app/create_program.html', context)


#
def create_program(request):

    name = request.POST.get('name')
    target = request.POST.get('target')
    description = request.POST.get('description')
    category_str = request.POST.get('category')
    ()

    try:
        program_list = Program.objects.filter(name=name, target=target, description=description)
        if program_list:
            print("program exists")
            ## Program already exists
            return render(request, 'exploit_app/create_program.html', context)
        else:

            categories = Category.objects.filter(name=category_str)
            if len(categories) > 0:
                # Use existing category if possible
                category = categories[0]
            else:
                # Category does not exist - create it
                category = Category(name=category_str)
                category.save()

            program = Program(name=name, target=target, description=description, category=category)
            program.save()
    except:
        print("program wrong")
        # Something went wrong
        return render(request, 'exploit_app/create_program.html',)


    context = {
                'program': program,
              }

    return redirect('program_view', program_id=program.id)
    #return render(request, 'exploit_app/program.html', context)




## Search DB for program(s). Allows searching by a target,
## keyword, or stage
def perform_program_search(request):
    target = request.GET.get('target', 'default_if_not_found_value')
    tag_name = request.GET.get('tag', 'default_if_not_found_value')
    stage_name = request.GET.get('dropDownStageButton', 'default_if_not_found_value')

    try:
        print("Stage ", stage_name)
        stage = Stage.objects.get(name=stage_name)
    except:
        stage = None

    program_list = Program.objects.all()

    filters = []

    ## Target
    if target:
        program_list = program_list.filter(target=target)
        target_filter = Filter("Target", target)
        filters.append(target_filter)

    # Keyword/tag
    if tag_name:
        program_list = Program.objects.filter(Q(description__contains=tag_name) | Q(name__contains=tag_name))
        tag_filter = Filter("Tag", tag_name)
        filters.append(tag_filter)

    # Program stage
    if stage:
        print("test")
        #program_list = program_list.filter(stages__name=stage.name)
        #tag_filter = Filter("Stage", stage.name)
        #filters.append(tag_filter)

    paginate_by = 2
    paginator = Paginator(program_list, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)


    context = {
                'program_list' : program_list,
                'page_obj' : page_obj
            }

    return render(request, 'exploit_app/program_search_results.html', context)



# Search programmes by:
# Name, target, stage
# return - program name, target, description, references, list of commands, list of stages
def perform_command_search(request):

    tag_name = request.GET.get('tag', 'default_if_not_found_value')
    try:
        tag = Tag.objects.get(name=tag_name)
    except:
        tag = None

    command_list = []

    # Tag - if the commands program has this tag, or the description contains this word
    if tag:
        command_list = Command.objects.filter(Q(tags__name=tag.name) | Q(description__contains=tag_name) | Q(name__contains=tag_name))
    else:
        command_list = Command.objects.filter(Q(description__contains=tag_name) | Q(name__contains=tag_name))

    paginate_by = 2
    paginator = Paginator(command_list, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
                'command_list' : command_list,
                'page_obj' : page_obj,
            }

    return render(request, 'exploit_app/command_search_results.html', context)



################## AUTO COMPLETE VIEWS #######################
def tag_autocomplete(request):

    qs = Tag.objects.filter(name__istartswith=request.GET.get('term'))
    titles = []
    for tag in qs:
        titles.append(tag.name)

    return JsonResponse(titles, safe=False)


def target_autocomplete(request):

    programs = Program.objects.all();
    targets = []

    for program in programs:
        target = program.target
        if target.lower().startswith(request.GET.get('term').lower()):
            targets.append(target)

    targets = list(dict.fromkeys(targets))
    return JsonResponse(targets, safe=False)
